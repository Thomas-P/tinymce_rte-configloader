/**
* @author thomas-p / https://github.com/Thomas-P
*/

// tiny has to load first
// own extension code 
var tinymce_rte = {};

;(function(tinymce_rte,tinymce) {
	
	if (!tinymce) {
		return console.error('Couldn\'t load dependency tinyMCE, break here.');
	}

	if (!MutationObserver) {
		return console.error('Couldn\'t load dependency MutationObserver, break here.')
	}


	// store orgininal init from tiny
	var originalInit = tinymce.init;
	// storage for options
	var tinyOptions;
	// selector for tinyMCE
	var selector;
	// init only the first time
	var firstInit;

	/**
	* override for the tinyMCE.init handle only the options
	*/
	var init = function(options) {
		if (firstInit) 
			return console.error('tinyMCE.init should only call one time');

		options = options || {};

		// override options with default from extension
		defaultOptions = tinymce_rte.defaultOptions || {}

		for (var key in defaultOptions) {
			if (defaultOptions.hasOwnProperty(key)) {
				options[key] = defaultOptions[key];
			}
		}

		// override options.setup with own integration
		options.setup = setup(options.setup);
		tinyOptions = options;

		if (options.selector)
			selector = String(options.selector);
		
		document.addEventListener('DOMContentLoaded', function() {
		
			originalInit.call(tinymce, tinyOptions);
			initMutationObserver();	
		
		}, false);

		firstInit = true;
	}

	/**
	* look for new elements
	*/
	var initMutationObserver = function() {

		var observer = new MutationObserver( function(mutations) {

			if (!selector)
				return;

			mutations.forEach( function(mutation) {

				for ( var i = 0; i < mutation.addedNodes.length; i++ ) {
					
					var node = mutation.addedNodes[i];

					if (!node || !node.classList || !node.tagName)
						continue;
					
					if (!node.dataset)
						node.dataset = {};

					if (node.dataset.isTiny)
						continue;
					
					if ( '.' == selector[0] ) {
						
						if ( ! node.classList.contains(selector.substr(1)) )
							continue;

					} else if ( '#' == selector[0] ) {

						if (node.id != selector.substr(1))
							continue;

					} else {

						if ( node.tagName.toLowerCase() != selector.toLowerCase() ) {
							continue;
						}

					}

					// add Tiny to node
					if (!node.id)
						node.id = new Date().getUTCMilliseconds();

					node.dataset.isTiny = true;
					tinyOptions.selector = '#' + node.id;
					originalInit.call(tinymce, tinyOptions);

				}

			})

		});
		
		observer.observe(document, { subtree: true, childList: true });
	}

	/**
	* setup override to manage changes
	*/
	var setup = function(setupMethod) {

		var editor, target, changeMethod;

		function getTarget() {
			if (!target) {
				//editor.targetElm.classList.remove('tinymce4_rte');
				target = editor.targetElm;/*.cloneNode(true);
				editor.targetElm.name+= '-copy';
				editor.targetElm.parentElement.appendChild(target);
				target.id = '';*/
			}
			return target;
		}


		function textChange() {
			var target = getTarget();
			var name = target.name;
			var found = name.match(/^data\[(.*)\]\[(.*)\]\[(.*)\]$/);
			if (found)
				changeMethod.apply(target,[found[1],found[2],found[3],name]);

		}


		return function(editor) {
			// handle optical field change
			var TBE_EDITOR = TBE_EDITOR || null;
			if ( TBE_EDITOR && TBE_EDITOR.fieldChanged && 'function' == typeof TBE_EDITOR.fieldChanged)
				changeMethod = TBE_EDITOR.fieldChanged;
			else
				changeMethod = function() {}
			if (setupMethod && 'function' == typeof setupMethod)
				setupMethod.call(this,editor);


			editor = editor;
			editor.on('change',textChange);
			//editor.on('submit',copyText);
		}
	}


	tinymce.init = init;

})(tinymce_rte,window.tinymce)




/**
* defaults should be generated by typo3 extension
**/
tinymce_rte.defaultOptions = {
//	'language' : 'de',
	'content_css' : 'file to content',
	'selector' : '.tinymce_rte',
/*	'external_plugins': {
		'typo3filemanager': '/typo3conf/ext/tinymce4_rte/Resources/Public/Plugins/Typo3FileManager/typo3filemanager.min.js'
	}*/
}

// load the init userscript here